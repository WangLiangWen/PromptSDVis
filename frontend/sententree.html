<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <title>左至右节点布局示例</title>
    <style>
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 2px;
        }

        .text {
            font-family: sans-serif;
            font-size: 12px;
            text-anchor: middle;
            /* 水平居中 */
            dominant-baseline: central;
            /* 垂直居中 */
        }

        .text-bg {
            fill: #f0f0f0;
            /* 灰色背景 */
        }

        .plus-circle {
            fill: #000000;
            /* 加号背景圆形 */
            cursor: pointer;
        }

        .plus-line {
            stroke: white;
            stroke-width: 2;
        }
    </style>
</head>

<body>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        const width = 1200, height = 400;
        const nodeSpacing = 150; // 节点之间的间距
        const startX = 80; // 起始X坐标
        const centerY = height / 2; // Y坐标保持居中

        const svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height);

        let dataset = {
            nodes: [
                { id: 0, name: "Prompt Addd", "has_similarity": false },
                {
                    id: 1, name: "Prompt Bvvv", "has_similarity": true,
                    "diffusiondb": [{ "similarity": 50, name: "B1" },
                    { "similarity": 70, name: "B2" }],
                    "laion4b": [{ "similarity": 90, name: "B3" },
                    { "similarity": 60, name: "B4" }]
                },
                { id: 2, name: "Prompt C", "has_similarity": false },
                { id: 3, name: "Prompt D", "has_similarity": false },
                { id: 4, name: "Prompt E", "has_similarity": false },
                {
                    id: 5, name: "Prompt E", "has_similarity": true,
                    "diffusiondb": [{ "similarity": 50, name: "E1" },
                    { "similarity": 70, name: "E2" }],
                    "laion4b": [{ "similarity": 90, name: "E3" },
                    { "similarity": 60, name: "E4" }]
                }
            ],
            links: [
                { source: 0, target: 1 },
                { source: 1, target: 2 },
                { source: 2, target: 3 },
                { source: 3, target: 4 },
                { source: 4, target: 5 }
            ]
        };

        // 计算节点的左至右布局位置
        dataset.nodes.forEach((node, i) => {
            node.x = startX + i * nodeSpacing; // 计算每个节点的x坐标
            node.y = centerY; // y坐标固定在中心
        });

        // 绘制连线
        const link = svg.selectAll(".link")
            .data(dataset.links)
            .enter().append("line")
            .attr("class", "link")
            .attr("x1", d => dataset.nodes[d.source].x)
            .attr("y1", d => dataset.nodes[d.source].y)
            .attr("x2", d => dataset.nodes[d.target].x)
            .attr("y2", d => dataset.nodes[d.target].y)
            .style("stroke", "#ccc")
            .style("stroke-width", 2);

        // 绘制文本背景
        const textBackground = svg.selectAll(".text-bg")
            .data(dataset.nodes)
            .enter()
            .append("rect")
            .attr("class", "text-bg");

        // 添加节点标签
        const text = svg.selectAll(".text")
            .data(dataset.nodes)
            .enter().append("text")
            .attr("class", "text")
            .attr("x", d => d.x)
            .attr("y", d => d.y)
            .text(d => d.name)
            .each(function (d) {
                const bbox = this.getBBox();
                d.bbox = bbox;
            });

        // 更新文本背景位置和大小
        textBackground
            .attr("x", d => d.bbox.x - 5)
            .attr("y", d => d.bbox.y - 2)
            .attr("width", d => d.bbox.width + 10)
            .attr("height", d => d.bbox.height + 4)
            .attr("fill", "#f0f0f0");

        function updateGraph() {

            const nodes = svg.selectAll(".node")
                .data(dataset.nodes, d => d.id);


            const enter_nodes = nodes.enter()
                .append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${d.x}, ${d.y})`);


            enter_nodes.append("text")
                .attr("class", "text")
                .text(d => d.name)
                .each(function (d) {
                    const bbox = this.getBBox();
                    d.bbox = bbox;
                    console.log(bbox)
                });
            // 为新节点添加文本背景
            enter_nodes.insert("rect", "text")
                .attr("class", "text-bg")
                .attr("x", d => d.bbox.x - 5)
                .attr("y", d => d.bbox.y - 2)
                .attr("width", d => d.bbox.width + 10)
                .attr("height", d => d.bbox.height + 4)
                .attr("fill", "#f0f0f0");


            const links = svg.selectAll(".link")
                .data(dataset.links);

            links.enter().append("line")
                .attr("class", "link")
                .attr("x1", d => dataset.nodes[d.source].x)
                .attr("y1", d => dataset.nodes[d.source].y)
                .attr("x2", d => dataset.nodes[d.target].x)
                .attr("y2", d => dataset.nodes[d.target].y)
                .style("stroke", "#ccc")
                .style("stroke-width", 2);


        }
        function addNewNodeBySimilarity(nodes, d) {
            const currentNodeIndex = nodes.findIndex(node => node.id === d.id);
            const currentNode = nodes[currentNodeIndex]; // Get the next node
            const nextNodeIndex = currentNodeIndex + 1; // Assumes there is a sequential next node
            const nextNode = nodes[nextNodeIndex]; // Get the next node

            diffusiondb_sim = currentNode.diffusiondb.map(d => ({ similarity: d.similarity, name: d.name }));
            laion4b_sim = currentNode.laion4b.map(d => ({ similarity: d.similarity, name: d.name }));
            diffusiondb_sim.sort((a, b) => b.similarity - a.similarity);

            laion4b_sim.sort((a, b) => b.similarity - a.similarity);

            diffusiondb_sim.forEach((data, index) => {
                // 计算新节点的位置
                let newX, newY;
                if (nextNode) {
                    newX = (d.x + nextNode.x) / 2;
                    newY = d.y - 50 * (index + 1);
                } else {
                    // 如果没有下一个节点，就在当前节点的右侧创建新节点
                    newX = d.x + nodeSpacing / 2;
                    newY = d.y - 50 * (index + 1);
                }
                const newNode = {
                    id: dataset.nodes.length,
                    name: data.name,
                    x: newX,
                    y: newY,
                    has_similarity: false
                };
                dataset.nodes.push(newNode);
                if (nextNode) {
                    dataset.links.push({ source: newNode.id, target: nextNode.id });
                }
                dataset.links.push({ source: d.id, target: newNode.id });

            });
            laion4b_sim.forEach((data, index) => {
                // 计算新节点的位置
                let newX, newY;
                if (nextNode) {
                    newX = (d.x + nextNode.x) / 2;
                    newY = d.y + 50 * (index + 1);
                } else {
                    // 如果没有下一个节点，就在当前节点的右侧创建新节点
                    newX = d.x + nodeSpacing / 2;
                    newY = d.y + 50 * (index + 1);
                }
                const newNode = {
                    id: dataset.nodes.length,
                    name: data.name,
                    x: newX,
                    y: newY,
                    has_similarity: false
                };
                dataset.nodes.push(newNode);
                if (nextNode) {
                    dataset.links.push({ source: newNode.id, target: nextNode.id });
                }

                dataset.links.push({ source: d.id, target: newNode.id });

            });
            updateGraph();

        }

      
        
        // 添加加号圆形和交叉线
        dataset.nodes.filter(d => d.has_similarity).forEach((d, i) => {
            const plusGroup = svg.append("g")
                .attr("class", "plus-group")
                .attr("transform", `translate(${d.bbox.x + d.bbox.width + 15}, ${d.y})`)
                .on("click", () => {
                    addNewNodeBySimilarity(dataset.nodes, d, i)
                });

            plusGroup.append("circle")
                .attr("class", "plus-circle")
                .attr("r", 8);

            plusGroup.append("line")
                .attr("class", "plus-line")
                .attr("x1", -5)
                .attr("y1", 0)
                .attr("x2", 5)
                .attr("y2", 0);

            plusGroup.append("line")
                .attr("class", "plus-line")
                .attr("x1", 0)
                .attr("y1", -5)
                .attr("x2", 0)
                .attr("y2", 5);

        });

    </script>
</body>

</html>